var fs = require("fs");
var path = require("path");
const { python, SampleDir, TextFile, SampleFile } = require("projen");

// Templated files.
const pythonPod = require('../.projenrc.templates/skaffold/python-pod')
const flake8 = require('../.projenrc.templates/flake8')

// Constants
const TEMPLATE_FOLDER = path.join(__dirname, "..", ".projenrc.templates")

class CustomPythonProject extends python.PythonProject {
  constructor(options) {

    super({
      ...options,
    });

    // Generate project.
    this.createSamplefiles(options)
    this.createDependabotConfig()
    this.createPythonCIChecks()
    this.extendTasks()
    this.createScriptFiles()
    this.createIniFiles(options)
  }

  // LM REVIEW: Would suggest using Mustache templating so that params can be passed when generating files with templated content.
  // Opted to return a JS method which is passed options and returns file content (stolen from here: https://github.com/projen/projen/blob/main/src/python/python-project.ts). Saves a Mustache dependency. Thoughts?
  createManagedFile(filename, readonly, textArr = null) {

    // If textArr was not passed, generate a default by reading the file contents.
    if (!textArr) {
      const filePath = fs.readFileSync(path.join(TEMPLATE_FOLDER, filename))
      textArr = filePath.toString().split("\n")
    }

    // Add a line to say that this file was generated by projen.
    if (readonly) {
      textArr.unshift('# This is a managed file generated by Projen. To edit, change the project template.\n')
    }

    new TextFile(this, filename, {
      lines: textArr,
      readonly: readonly
    })
  }

  // Create samples to direct the user to follow the standard layout.
  createSamplefiles(options) {
    new SampleDir(this, "src", { sourceDir: path.join(TEMPLATE_FOLDER, "src") })
    new SampleDir(this, "tests", { sourceDir: path.join(TEMPLATE_FOLDER, "tests") })
    new SampleFile(this, "Dockerfile", { sourcePath: path.join(TEMPLATE_FOLDER, "Dockerfile") })
    new SampleFile(this, "skaffold.yml", { sourcePath: path.join(TEMPLATE_FOLDER, "skaffold.yml") })
    new SampleDir(this, "skaffold", { files: { [options.name + ".yml"]: pythonPod (options) }})
  }

  // Files for testing, linting, typing etc that shouldn't need editing.
  createIniFiles(options) {
    this.createManagedFile('./mypy.ini', true)
    this.createManagedFile('./.flake8', true, flake8(options).toString().split("\n"))
    this.createManagedFile('./.coveragerc', true)
    this.createManagedFile('./.darglint', true)
    this.createManagedFile('./noxfile.py', true)
  }

  // Generate placeholders for easy scripts. (Some may need editing).
  createScriptFiles() {
    this.createManagedFile('scripts/unit.sh', true)
    this.createManagedFile('scripts/start.sh', false)
    this.createManagedFile('scripts/stop.sh', false)
    this.createManagedFile('scripts/lint.sh', true)
  }

  // Dependabot config.
  createDependabotConfig() {
    this.createManagedFile(".github/dependabot.yml", true)
  }

  // CI Scripts.
  createPythonCIChecks() {
    this.createManagedFile(".github/workflows/on-push.yml", true)
  }

  // Skaffold.
  setupSkaffoldTask(operation) {
    const skaffold = this.addTask(operation, {
      description: "Start skaffold dev loop",
      exec: 'minikube status > /dev/null || minikube start'
    })
    skaffold.exec('kubectl config use-context minikube && echo "Your Kubernetes context has been set to use Minikube rather than prod or staging"')
    skaffold.exec(`skaffold ${operation}`)
  }

  extendTasks() {
    this.setupSkaffoldTask("dev")
    this.setupSkaffoldTask("run")
    this.removeTask("build")
    this.addTask('build', {
      description: "Build a docker image",
      exec: `docker build -t ${path.parse(path.join(__dirname, "..", "..")).name} .`,
    })
    this.removeTask("test")
    this.addTask('test', {
      description: "Run Python Tests",
      exec: "pytest src",
    })
  }

}
module.exports.CustomPythonProject = CustomPythonProject